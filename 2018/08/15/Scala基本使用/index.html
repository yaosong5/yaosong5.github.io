<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="纵浪大化中，不喜亦不悲"><title>Scala基本使用-杂记 | 钢铁锅</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Scala基本使用-杂记</h1><a id="logo" href="/.">钢铁锅</a><p class="description">应尽便须尽，无复独多虑</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Scala基本使用-杂记</h1><div class="post-meta">Aug 15, 2018<span> | </span><span class="category"><a href="/categories/语言/">语言</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#定义方法"><span class="toc-number">1.</span> <span class="toc-text">定义方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数的定义-gt"><span class="toc-number">2.</span> <span class="toc-text">函数的定义=&gt;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数和方法的区别"><span class="toc-number">3.</span> <span class="toc-text">函数和方法的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#神奇的下划线"><span class="toc-number">4.</span> <span class="toc-text">神奇的下划线</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数组、映射、元组、集合"><span class="toc-number"></span> <span class="toc-text">数组、映射、元组、集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#数组"><span class="toc-number">1.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#map方法"><span class="toc-number">2.</span> <span class="toc-text">map方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#trait-关键字"><span class="toc-number">2.1.</span> <span class="toc-text">trait 关键字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组的常用函数"><span class="toc-number">3.</span> <span class="toc-text">数组的常用函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#apply方法"><span class="toc-number">3.1.</span> <span class="toc-text">apply方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#元组"><span class="toc-number">4.</span> <span class="toc-text">元组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#将对偶的转成映射"><span class="toc-number">4.1.</span> <span class="toc-text">将对偶的转成映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拉链操作"><span class="toc-number">4.2.</span> <span class="toc-text">拉链操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#集合"><span class="toc-number"></span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#foreach"><span class="toc-number">1.</span> <span class="toc-text">foreach</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map"><span class="toc-number">2.</span> <span class="toc-text">Map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List"><span class="toc-number">3.</span> <span class="toc-text">List</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fold可以指定初始值"><span class="toc-number">4.</span> <span class="toc-text">fold可以指定初始值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#aggregate-聚合"><span class="toc-number">5.</span> <span class="toc-text">aggregate 聚合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#flatten-将数据压缩"><span class="toc-number">6.</span> <span class="toc-text">flatten 将数据压缩</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#对象"><span class="toc-number"></span> <span class="toc-text">对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#单例对象"><span class="toc-number">1.</span> <span class="toc-text">单例对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#伴生对象"><span class="toc-number">2.</span> <span class="toc-text">伴生对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#apply方法-1"><span class="toc-number">2.1.</span> <span class="toc-text">apply方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#应用程序对象"><span class="toc-number">3.</span> <span class="toc-text">应用程序对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造函数"><span class="toc-number">4.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#柯里化的两种表达方式"><span class="toc-number">5.</span> <span class="toc-text">柯里化的两种表达方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#继承-代理-装饰-之间的区别"><span class="toc-number">6.</span> <span class="toc-text">继承 代理 装饰 之间的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#泛型"><span class="toc-number"></span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#gt-lt-gt-lt"><span class="toc-number">1.</span> <span class="toc-text">&gt; &lt; &gt;= &lt;=</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#视图定界-view-bound-lt"><span class="toc-number">1.1.</span> <span class="toc-text">视图定界 view bound &lt;%</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#上下文定界-content-bound"><span class="toc-number">1.2.</span> <span class="toc-text">上下文定界 : content bound</span></a></li></ol></li></ol></div></div><div class="post-content"><p>[TOC]</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fukx028pz0j313t0op400.jpg" alt=""></p>
<p>Var和val</p>
<p>var 修饰的变量可改变，val 修饰的变量不可改变；但真的如此吗？事实上，var 修饰的对象引用可以改变，val 修饰的则不可改变，但对象的状态却是可以改变的。</p>
<h2 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span><span class="title"> m1</span></span>(x:<span class="type">Int</span>,y:<span class="type">Int</span>):<span class="type">Int</span>=x*y</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="函数的定义-gt"><a href="#函数的定义-gt" class="headerlink" title="函数的定义=&gt;"></a>函数的定义=&gt;</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> func:<span class="type">Int</span> =&gt;<span class="type">String</span>=&#123;x=x.toString&#125;</span><br><span class="line">也可以写成</span><br><span class="line"><span class="keyword">val</span> func1=(x:<span class="type">Int</span>)=&gt;x.toString</span><br></pre></td></tr></table></figure>
<h2 id="函数和方法的区别"><a href="#函数和方法的区别" class="headerlink" title="函数和方法的区别"></a>函数和方法的区别</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">定义一个方法</span><br><span class="line"><span class="function"><span class="keyword">def</span><span class="title"> m2</span></span>(f:(<span class="type">Int</span>,<span class="type">Int</span>)=&gt;<span class="type">Int</span>) =f(<span class="number">2</span>,<span class="number">6</span>)</span><br><span class="line">定义一个函数</span><br><span class="line"><span class="keyword">val</span> f2 =(x:<span class="type">Int</span>,y:<span class="type">Int</span>) =&gt;x-y</span><br><span class="line">调用</span><br><span class="line">f2(m2)</span><br></pre></td></tr></table></figure>
<h2 id="神奇的下划线"><a href="#神奇的下划线" class="headerlink" title="神奇的下划线"></a>神奇的下划线</h2><p>将方法转换成函数</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span><span class="title"> m2</span></span>(x:<span class="type">Int</span>,y:<span class="type">Int</span>):<span class="type">Int</span> = x+y</span><br><span class="line"><span class="keyword">val</span> f2(a:<span class="type">Int</span>,y:<span class="type">Int</span>)=&gt;x+y</span><br><span class="line"><span class="keyword">val</span> f2 = m2 _</span><br></pre></td></tr></table></figure>
<h1 id="数组、映射、元组、集合"><a href="#数组、映射、元组、集合" class="headerlink" title="数组、映射、元组、集合"></a>数组、映射、元组、集合</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> arr = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Int</span>](<span class="number">10</span>) <span class="comment">//创建数组，无值</span></span><br><span class="line"><span class="keyword">val</span> arr1 = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)  <span class="comment">//直接实例化</span></span><br><span class="line"><span class="keyword">for</span>(e&lt;- arr) **<span class="keyword">yield</span>** e*<span class="number">2</span>; 用<span class="keyword">yield</span>关键字可以生成一个新的数组 生成的类型和循环的类型是一样的</span><br></pre></td></tr></table></figure>
<h2 id="map方法"><a href="#map方法" class="headerlink" title="map方法"></a>map方法</h2><p>map方法是将每一个元素拿来操作<br>arr.map(_*2) map方法更好用  map是排序？</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">a.map((x:<span class="type">Int</span>)=&gt;x*<span class="number">10</span>)<span class="comment">//匿名函数</span></span><br></pre></td></tr></table></figure>
<p>由于知道a中的数据类型 可以将Int省略<br>a.map(x=&gt;x<em>10)<br>还可以用<em>占位符，进行进一步的省略<br>a.map(</em> </em> 10)</p>
<p>所有偶数取出来然后再乘以10<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr.filter((x:<span class="type">Int</span>)=&gt;x%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">arr.filter(x=&gt;x%<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">arr.filter(_%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">arr.filter(_%<span class="number">2</span>==<span class="number">0</span>).map(_*<span class="number">10</span>)</span><br><span class="line"><span class="keyword">val</span> p =  println _</span><br></pre></td></tr></table></figure></p>
<p>可以将方法转换成函数用利用 _</p>
<h3 id="trait-关键字"><a href="#trait-关键字" class="headerlink" title="trait 关键字"></a>trait 关键字</h3><h2 id="数组的常用函数"><a href="#数组的常用函数" class="headerlink" title="数组的常用函数"></a>数组的常用函数</h2><p>在超类<br>TraversableLike中定义了这些函数<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> arr = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">arr.sum 总数</span><br><span class="line">arr.sorted 排序</span><br><span class="line">arr.sorted.reverse 逆序</span><br><span class="line">arr.sortBy(x=&gt;x)按照本身来排序</span><br><span class="line">arr.sortWith(_&gt;_)从大到小排序 &lt; 从小到大排序</span><br><span class="line">arr.sortWith((x,y))</span><br><span class="line">##</span><br></pre></td></tr></table></figure></p>
<p>映射 类比java中的map<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> m = <span class="type">Map</span>(<span class="string">"a"</span>-&gt;<span class="number">1</span>,<span class="string">"b"</span>-&gt;<span class="number">2</span>)</span><br><span class="line">m(<span class="string">"a"</span>) 取值</span><br></pre></td></tr></table></figure></p>
<p>里边的值不能更改<br>如果是mulitble的包就可以更改了<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.getOrElse(<span class="string">"c"</span>,<span class="number">0</span>) 找c 如果没有c就创建<span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<h3 id="apply方法"><a href="#apply方法" class="headerlink" title="apply方法"></a>apply方法</h3><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>val t = (1,”spark”,2.0); 值类型都不一定</p>
<p>m.+=((“c”,1))  与 m+=(“m”-&gt;1) 写法相同<br>val t,(x,y,z) = (“a”,1,2.0)<br>t是变量，x y z 是键 对应三个值，取值的时候 直接用x就可以取值</p>
<h3 id="将对偶的转成映射"><a href="#将对偶的转成映射" class="headerlink" title="将对偶的转成映射"></a>将对偶的转成映射</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> arr  = <span class="type">Array</span>((<span class="string">"a"</span>,<span class="number">1</span>),(<span class="string">"b"</span>,<span class="number">2</span>))</span><br><span class="line">arr.toMap 就可以转成映射</span><br></pre></td></tr></table></figure>
<h3 id="拉链操作"><a href="#拉链操作" class="headerlink" title="拉链操作"></a>拉链操作</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = <span class="type">Array</span>(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>)</span><br><span class="line"><span class="keyword">val</span> b = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">a.zip(b)</span><br></pre></td></tr></table></figure>
<p>将其拉在一起变成数组，元素为元组</p>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>序列Seq,集Set,映射Map<br>集合分为可变和不可变的 mutable 和 immutable<br>注意和val的对比<br>将0插入来lst前面生成一个新的集合</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> lst2 = <span class="number">1</span> :: lst1; </span><br><span class="line"><span class="keyword">val</span> lst3 = lst1.::(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">val</span> lst4 = <span class="number">0</span> +: lst1</span><br><span class="line"><span class="keyword">val</span> lst5 = lst1.+:(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>将一个元素添加到lst后面产生一个新的集合</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> lst6 = lst1:+<span class="number">3</span></span><br><span class="line"><span class="keyword">val</span> lst0 = <span class="type">List</span>(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p>将2个list合并成一个新的List</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> lst7 = lst1 ++ lst0</span><br></pre></td></tr></table></figure>
<p>将lst0插入到lst前面生成一个新的集合</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> lst8 = lst1 ++: lst0</span><br></pre></td></tr></table></figure>
<h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><p>foreach是将其值取出来，不会新生成一个集合<br>map将值取出来会新生成一个集合</p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map本身不支持排序<br>但是有toList方法 无括号，可以支持排序</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br></pre></td></tr></table></figure>
<p>list.par转成并行化集合<br>list.par.reduce(_+_) 将其放在多个reduce中执行，数据量大的时候将会变得很快<br>reduce不是并行集合的话，就是调用的底层<br>reduceLeft(不能并行了)</p>
<h2 id="fold可以指定初始值"><a href="#fold可以指定初始值" class="headerlink" title="fold可以指定初始值"></a>fold可以指定初始值</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.par.fold(<span class="number">0</span>)(_+_)</span><br></pre></td></tr></table></figure>
<h2 id="aggregate-聚合"><a href="#aggregate-聚合" class="headerlink" title="aggregate 聚合"></a>aggregate 聚合</h2><p>需要传两个函数，第一个函数是对元素进行操作，第二函数是对局部操作的结果进行操作</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>（<span class="type">List</span>(<span class="number">1</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">8</span>),<span class="type">List</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)）</span><br><span class="line">list.aggregate(<span class="number">0</span>)(_+_.sum,_+_)</span><br></pre></td></tr></table></figure>
<p>union 并集，intersect交集，diff差集</p>
<h2 id="flatten-将数据压缩"><a href="#flatten-将数据压缩" class="headerlink" title="flatten 将数据压缩"></a>flatten 将数据压缩</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>（<span class="type">List</span>(<span class="number">1</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">8</span>),<span class="type">List</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)）</span><br><span class="line">listAll.flatten</span><br><span class="line"><span class="type">List</span>(<span class="number">1</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) 产生新的集合</span><br></pre></td></tr></table></figure>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>主构造器里面的所有方法都会被执行</p>
<h2 id="单例对象"><a href="#单例对象" class="headerlink" title="单例对象"></a>单例对象</h2><p>所有的object都是一个单例（把class替换成object）<br>不要new，直接等于类名就是调用的一个<strong>单例对象</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span><span class="title"> Dog</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span><span class="title"> main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">val</span> d = <span class="type">Dog</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h2><p>就是对象名和类名一样，并且在一个scala文件中<br>可以和类<strong>互相访问私有属性</strong><br>scala中返回的就是unit就是返回的一个括号</p>
<h3 id="apply方法-1"><a href="#apply方法-1" class="headerlink" title="apply方法"></a>apply方法</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="type">Dog</span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">def</span><span class="title"> apply</span></span>():<span class="type">Unit</span> = &#123;</span><br><span class="line">  print ();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">def</span><span class="title"> apply</span></span>(name:<span class="type">String</span>):<span class="type">Unit</span> = &#123;</span><br><span class="line">  print(name)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">def</span><span class="title"> main</span></span>()&#123;</span><br><span class="line"> <span class="comment">//会调用第一个无参数的apply方法</span></span><br><span class="line"> <span class="keyword">val</span> d1 = <span class="type">Dog</span>()</span><br><span class="line"> <span class="comment">//会调用第有参数的apply方法</span></span><br><span class="line"> <span class="keyword">val</span> d2 = <span class="type">Dog</span>(<span class="string">"haha"</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="应用程序对象"><a href="#应用程序对象" class="headerlink" title="应用程序对象"></a>应用程序对象</h2><p>没有什么实际作用</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>用this关键字定义辅助构造器<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span><span class="title"> this</span></span>(name:<span class="type">String</span>,age:<span class="type">Int</span>,gender:<span class="type">String</span>)&#123;</span><br><span class="line"><span class="comment">//每个服务构造器必须以主构造器或者其他的辅助构造器的调用开始</span></span><br><span class="line"><span class="comment">//主构造器就是类名上直接填写参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数与方法的互换， 神奇的下划线<br>要想传到map里面，必须得是函数</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span><span class="title">  fangfa方法</span></span></span><br><span class="line"><span class="function"><span class="title">val  func 函数</span></span></span><br><span class="line"><span class="function"><span class="title">val arr = Array</span></span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">arr.map(func(<span class="number">5</span>))</span><br><span class="line">arr.map(func())</span><br><span class="line"><span class="keyword">val</span> m = fangfa _  方法func转成函数</span><br><span class="line">fangfa()  也可以转函数</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span><span class="title"> m</span></span>(x:<span class="type">Int</span>) = (y:int)=&gt;x*y</span><br></pre></td></tr></table></figure>
<h2 id="柯里化的两种表达方式"><a href="#柯里化的两种表达方式" class="headerlink" title="柯里化的两种表达方式"></a>柯里化的两种表达方式</h2><p>柯里化是主要是通过类型类匹配的</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span><span class="title"> m1</span></span>(x:<span class="type">Int</span>) = (y:<span class="type">Int</span>)=&gt;x*y</span><br><span class="line"><span class="function"><span class="keyword">def</span><span class="title"> m2</span></span>(x:<span class="type">Int</span>)(y:<span class="type">Int</span>)=&gt;x*y</span><br></pre></td></tr></table></figure>
<p>柯里化会先执行一部分，返回一个函数<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">def</span><span class="title"> multi= </span></span>(x:<span class="type">Int</span>) =&gt;&#123;</span><br><span class="line">    x*x</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span><span class="title"> main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> arr = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">val</span> a1 = multi(<span class="number">10</span>)</span><br><span class="line">    println(<span class="string">s"平方式：<span class="subst">$&#123;a1&#125;</span>"</span>)</span><br><span class="line">    <span class="comment">//按照规则 map只能参数只能是函数，multi是一个方法，但是在柯里化的时候，会先返回一个中间结果是函数</span></span><br><span class="line">    <span class="keyword">val</span> a2 = arr.map(multi)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="继承-代理-装饰-之间的区别"><a href="#继承-代理-装饰-之间的区别" class="headerlink" title="继承 代理 装饰 之间的区别"></a>继承 代理 装饰 之间的区别</h2><p>继承是类的增强</p>
<p>代理是对实例，方法的增强</p>
<p>装饰也是对方法的增强</p>
<p>implicit def 隐式的，隐式转化的包在predef中</p>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;? <span class="keyword">extends</span> clazz&gt; 传入的数据是clazz的子类   </span><br><span class="line">&lt;? <span class="keyword">super</span> clazz&gt; 传入的数据是clazz的父类</span><br></pre></td></tr></table></figure>
<h2 id="gt-lt-gt-lt"><a href="#gt-lt-gt-lt" class="headerlink" title="&gt; &lt; &gt;= &lt;="></a>&gt; &lt; &gt;= &lt;=</h2><p>以上操作符，在scala中都是方法</p>
<h3 id="视图定界-view-bound-lt"><a href="#视图定界-view-bound-lt" class="headerlink" title="视图定界 view bound &lt;%"></a>视图定界 view bound &lt;%</h3><p>scala泛型</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>[<span class="type">T</span>] </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chooser</span></span>[<span class="type">T</span> &lt;: <span class="type">Comparable</span>[<span class="type">T</span>]](firit: <span class="type">T</span>, second: <span class="type">T</span>): <span class="type">T</span> = &#123; </span><br><span class="line">	first </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>隐式转换：我自己的隐式上下文</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyPredef</span></span>&#123; </span><br><span class="line"><span class="keyword">implicit</span> 函数 </span><br><span class="line"><span class="keyword">implicit</span> 值 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>viewbound要求传入一个隐式转换函数</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chooser</span>[<span class="type">T</span> &lt;% <span class="type">Ordered</span>[<span class="type">T</span>]] </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bigger</span></span>(first: <span class="type">T</span>, second: <span class="type">T</span>) : <span class="type">T</span> = &#123; </span><br><span class="line">	<span class="keyword">if</span>(first &gt; second) first <span class="keyword">else</span> second </span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chooser</span>[<span class="type">T</span>] </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bigger</span></span>(first: <span class="type">T</span>, second: <span class="type">T</span>)(<span class="keyword">implicit</span> ord: <span class="type">T</span> =&gt; <span class="type">Ordered</span>[<span class="type">T</span>]) : <span class="type">T</span> = &#123; </span><br><span class="line">	<span class="keyword">if</span>(first &gt; second) first <span class="keyword">else</span> second </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>contextbound要求传入一个隐式转换值</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chooser</span>[<span class="type">T</span>: <span class="type">Ordering</span>] </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bigger</span></span>(first: <span class="type">T</span>, second: <span class="type">T</span>) : <span class="type">T</span> = &#123; </span><br><span class="line"><span class="keyword">val</span> ord = implicitly[<span class="type">Ordering</span>[<span class="type">T</span>]] </span><br><span class="line"><span class="keyword">if</span>(ord.gt(first, second)) first <span class="keyword">else</span> second </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chooser</span>[<span class="type">T</span>] </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bigger</span></span>(first: <span class="type">T</span>, second: <span class="type">T</span>)(<span class="keyword">implicit</span> ord : <span class="type">Ordering</span>[<span class="type">T</span>]) : <span class="type">T</span> = &#123; </span><br><span class="line"><span class="keyword">if</span>(ord.gt(first, second)) first <span class="keyword">else</span> second </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>[+T]<br>[-T]</p>
<p>相当于传入了一个隐式转换的函数<br>一定要传入一个隐式转换函数</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span><span class="title"> Chooser </span>[t &lt;% <span class="type">Order</span>[<span class="type">T</span>]]</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span><span class="title"> choose</span></span>(first <span class="type">T</span>,second <span class="type">T</span>) :<span class="type">T</span> =&#123;</span><br><span class="line">  <span class="comment">//val ord = implicitly[Ordering[T]]</span></span><br><span class="line">  <span class="comment">// if(ord.gt(first,second))) first else second;</span></span><br><span class="line">   <span class="keyword">if</span>(first.compare(second) &gt; <span class="number">0</span>) first <span class="keyword">else</span> second;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">implict <span class="class"><span class="keyword">object</span><span class="title"> girlOrdering extends Ordering</span>[girl]</span>&#123;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span><span class="title"> compare</span></span>(x:girl,y:girl):<span class="type">Int</span> = &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">== 和这个实现的效果是一样的,只是取了一个名字</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> girlOrder = <span class="keyword">new</span> <span class="type">Ordering</span>[<span class="type">Girl</span>]&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="上下文定界-content-bound"><a href="#上下文定界-content-bound" class="headerlink" title="上下文定界 : content bound"></a>上下文定界 : content bound</h3><p>相当于传入了一个隐式转换的值</p>
<p>关于实体类Predef的关系</p>
</div><div class="tags"><a href="/tags/Scala/">Scala</a></div><div class="post-nav"><a class="pre" href="/2018/08/15/Spark算子/">Spark算子案例</a><a class="next" href="/2018/08/15/Hadoop-构成及HA-/">Hadoop-HA-Federation机制</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://gangtieguo.cn"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spark-On-Yarn/">Spark-On-Yarn</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/tool/">tool</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/博客/">博客</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/大数据/">大数据</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/安装部署/">安装部署</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/工程框架/">工程框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/快捷键/">快捷键</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/总结/">总结</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/框架/">框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/环境配置/">环境配置</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/碎片知识/">碎片知识</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/组件/">组件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/语言/">语言</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Mysql/" style="font-size: 15px;">Mysql</a> <a href="/tags/Docker/" style="font-size: 15px;">Docker</a> <a href="/tags/Jenkins/" style="font-size: 15px;">Jenkins</a> <a href="/tags/CDH/" style="font-size: 15px;">CDH</a> <a href="/tags/Docker-machine/" style="font-size: 15px;">Docker-machine</a> <a href="/tags/安装部署/" style="font-size: 15px;">安装部署</a> <a href="/tags/Hadoop/" style="font-size: 15px;">Hadoop</a> <a href="/tags/HBase/" style="font-size: 15px;">HBase</a> <a href="/tags/原理/" style="font-size: 15px;">原理</a> <a href="/tags/操作/" style="font-size: 15px;">操作</a> <a href="/tags/HDFS/" style="font-size: 15px;">HDFS</a> <a href="/tags/Shell/" style="font-size: 15px;">Shell</a> <a href="/tags/Hive/" style="font-size: 15px;">Hive</a> <a href="/tags/使用/" style="font-size: 15px;">使用</a> <a href="/tags/报表/" style="font-size: 15px;">报表</a> <a href="/tags/Json/" style="font-size: 15px;">Json</a> <a href="/tags/Scala/" style="font-size: 15px;">Scala</a> <a href="/tags/Kafka/" style="font-size: 15px;">Kafka</a> <a href="/tags/大数据/" style="font-size: 15px;">大数据</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/开发/" style="font-size: 15px;">开发</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Ambari/" style="font-size: 15px;">Ambari</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/SSH/" style="font-size: 15px;">SSH</a> <a href="/tags/Spark/" style="font-size: 15px;">Spark</a> <a href="/tags/Yarn/" style="font-size: 15px;">Yarn</a> <a href="/tags/RDD/" style="font-size: 15px;">RDD</a> <a href="/tags/SparkSQL/" style="font-size: 15px;">SparkSQL</a> <a href="/tags/SparkStreaming/" style="font-size: 15px;">SparkStreaming</a> <a href="/tags/ELK/" style="font-size: 15px;">ELK</a> <a href="/tags/es/" style="font-size: 15px;">es</a> <a href="/tags/FLINK/" style="font-size: 15px;">FLINK</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/Hue/" style="font-size: 15px;">Hue</a> <a href="/tags/命令/" style="font-size: 15px;">命令</a> <a href="/tags/zk/" style="font-size: 15px;">zk</a> <a href="/tags/技术/" style="font-size: 15px;">技术</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/Other/" style="font-size: 15px;">Other</a> <a href="/tags/快捷键/" style="font-size: 15px;">快捷键</a> <a href="/tags/Mac/" style="font-size: 15px;">Mac</a> <a href="/tags/Idea/" style="font-size: 15px;">Idea</a> <a href="/tags/Finder/" style="font-size: 15px;">Finder</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/09/04/Spark-on-Yarn源码解析(四)Spark业务代码的执行及其任务分配调度stage划分/">Spark-on-Yarn源码解析(四)Spark业务代码的执行及其任务分配调度stage划分</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/04/Spark-on-Yarn源码解析(三)client做的事情/">Spark-on-Yarn源码解析(三)client做的事情</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/04/Spark-on-Yarn源码解析(二)Spark-Submit解析/">Spark-on-Yarn源码解析(二)Spark-Submit解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/04/Spark-on-Yarn源码解析(一)Yarn任务解析/">Spark-on-Yarn源码解析(一)Yarn任务解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/20/MapReduce中Shuffle中的机制/">MapReduce中Shuffle中的机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/16/SparkSQL介绍/">SparkSQL介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/16/Spark-On-yarn/">Spark-On-Yarn模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/16/SparkStreaming介绍/">SparkStreaming介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/16/SparkRDD介绍/">SparkRDD介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/16/Hadoop零碎知识点/">Hadoop零碎知识点</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">钢铁锅.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>